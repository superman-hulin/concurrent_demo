package com.concurrent;

/**
 * @program: su-concurrent
 * @description: Monitor的原理
 *  java对象头
 *     java对象在内存中由两部分组成（对象头和对象中的成员变量）
 *     以32位虚拟机为例，普通对象的对象头占64位（32位为Mark Word，32位为Klass Word），数组对象的对象头占96位（额外加32位的数组长度）
 *     Klass Word是用来指向该对象所属的类对象，从而记住该对象是什么类型。
 *     Mark Word在不同的状态下有不同的结构
 *
 *  Monitor
 *      可以理解为就是我们提到的锁，被翻译为监视器或管程
 *      每个java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word中就被设置指向Monitor对象的指针
 *      synchronized不管加在哪里，原理都是给某个对象上锁，当线程t1访问一个加了synchronized（obj）的临界区代码时，会尝试将obj对象（java的对象）和Monitor对象（操作系统的对象）相关联
 *      关联是通过obj对象头中的Mark Word中的指针指向Monitor对象的地址，Monitor对象有很多属性，核心的有WaitSet、EntryList和Owner。关联后，Owner属性会指向线程t1，记录当前锁属于哪个线程。
 *      假如又有个线程t2访问该临界区，首先会检查该obj有没有关联一个Monitor对象，如果有，则看Owner有没有指向某个线程，如果有的话，则线程t2被链入EntryList（阻塞队列），进入blocked状态
 *      同理如果有t3的话，也一样。当线程t1执行完临界区代码后，会唤醒EntryList中的线程，然后这些线程进行竞争（具体策略取决于jdk底层） 做下一个Owner。同一个obj只会跟同一个Monitor对象关联
 *      WaitSet
 *  synchronized的要点
 *      如果临界区中的同步代码块发生了异常，锁也会正常释放。
 *  java6之后对synchronized关键字获取锁的方式进行了改进
 *      之前是让synchronized中的obj关联一个Monitor对象（真正的锁），但是Monitor对象是操作系统提供的，使用它的成本是比较高的，影响程序的性能。
 *      从直接使用Monitor锁（重量级锁）改为使用轻量级锁和偏向锁进行优化
 *      重量级锁的缺点：很多情况下临界区的访问并没有产生竞争，比如不同线程使用的时间是错开的，那么每次上锁解锁太影响性能
 *      轻量级锁解决方案（挂书包）：一开始不对临界区进行上锁，而是通过一种检查机制（轻量级锁），当线程a访问临界区时，首先看检查机制是否满足自己当前可以访问，如果是的，则可以安全访问。
 *                     如果自己当前不能访问，则进入阻塞状态，并通知另一线程下次采用上锁的方式
 *                     即临界区如果没有竞争则使用轻量级锁，如果以后有了竞争，则升级为重量级锁
 *      偏向锁解决方案（刻名字）：如果临界区长时间没有其他线程会访问，那么轻量级锁的方式也会麻烦，则引入偏向锁，即临界区专属于某个线程使用。这是假设长期没有别的线程和它竞争。
 *                   如果有竞争了，偏向锁也会升级为轻量级锁的方式。
 *      批量重刻名：背景：线程a在20个临界区都采用偏向锁方式，当a后来不使用时，线程b来使用这些临界区时，需要把之前偏向于a的标识去掉并修改为b的标识。
 *                    所以jvm提供批量重刻名机制来实现。
 *                一个类的偏向锁撤销达到阈值20
 *      不能刻名字：批量撤销该类对象的偏向锁太频繁，则该类对象不适合使用偏向锁方式，则设置该类不可偏向，只能是轻量级锁方式
 *
 *  自旋优化
 *      重量级锁竞争的时候，还可以使用自旋来进行优化，也就是相当于循环不断的去看锁是否释放，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞（就无须进行上下文切换）
 *      自旋的线程是需要使用cpu的，所以这种优化是对于那种多核cpu的。
 *      如果拥有锁的线程的同步代码块执行比较久，那么自旋的线程不断自旋重试都没成功后，则就进入阻塞
 *      在java6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次。反之，就少自旋甚至不自旋，总之比较智能。
 *      自旋会占用cpu时间，单核cpu自旋就是浪费，多核cpu自旋才能发挥优势
 *      java7之后不能控制是否开启自旋功能，由底层控制
 * @author: Su
 * @create: 2020-09-18 19:56
 **/
public class Monitor {



}
